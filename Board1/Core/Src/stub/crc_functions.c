#include "crc_functions.h"

#include "string.h"  // for memcpy

#include "crc.h"
extern CRC_HandleTypeDef hcrc;

/*
 * NOTE:
 * The CRC peripheral is configured with Input Data Format = BYTES
 * (CRC_INPUTDATA_FORMAT_BYTES, as generated by CubeMX).
 *
 * For this reason, although HAL_CRC_Calculate() formally expects a uint32_t*
 * pointer, it is safe and intentional to cast a uint8_t* buffer to uint32_t*.
 *
 * Internally, when InputDataFormat is set to BYTES, the HAL does NOT access the
 * buffer as 32-bit words. Instead, it reinterprets the pointer as uint8_t* and
 * processes the data byte-by-byte (see CRC_Handle_8() in stm32g4xx_hal_crc.c),
 * correctly handling unaligned buffers and lengths not multiple of 4.
 *
 * Therefore:
 *  - bufferLength is expressed in BYTES
 *  - no 32-bit alignment of the buffer is required
 *  - the cast to uint32_t* is only needed to match the HAL API signature
 */

void computeCRC(uint8_t* buffer, uint32_t bufferLength){
    uint32_t crc;
    crc = HAL_CRC_Calculate(&hcrc, (uint32_t*) buffer, bufferLength);
    memcpy(&(buffer[bufferLength]), &crc, CRC_SIZE);
}

uint8_t compareCRC(uint8_t* buffer, uint32_t bufferLength){
    uint32_t crc_received;
    memcpy(&crc_received, &(buffer[bufferLength]), CRC_SIZE);

    uint32_t crc_computed;
    crc_computed = HAL_CRC_Calculate(&hcrc, (uint32_t*) buffer, bufferLength);

    if (crc_computed == crc_received){
        return 1;
    } else {
    	return 0;
    }
}
